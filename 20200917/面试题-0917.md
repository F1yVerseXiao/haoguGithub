## 1.**每个HTML文件里面都有一个很重要的东西，Doctype，知道这是干什么的么？**

答：<!DOCTYPE>声明位于文档中最前面的位置，处于<html>标签之前。此标签可告知浏览器文档使用哪种HTML或XHTML规范。（重点：告诉浏览器按照何种规范解析页面）

## 2.**常用浏览器有哪些，内核都是什么？**

**答： **常用浏览器有chrome、safari、 IE、火狐(firefox) 、 Opera 、360、搜狗等

| 浏览器  |      内核      | 备注                                                         |
| :------ | :------------: | :----------------------------------------------------------- |
| IE      |    Trident     | IE、猎豹安全、360极速浏览器、百度浏览器                      |
| firefox |     Gecko      | 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 |
| Safari  |     webkit     | 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 |
| chrome  | Chromium/Blink | 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 |
| Opera   |     blink      | Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核,现在跟随chrome用blink内核。 |

## 3.**简述一下你对HTML语义化的理解？**

答：

1. 去掉或丢失样式的时候能够让页面呈现出清晰的结构。
2. 有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。
3. 方便其它设备解析。
4. 便于团队开发和维护，语义化根据可读性。

## 4.**HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5**？

答：新增加了图像、位置、存储、多任务等功能。
新增元素：

1. canvas
2. 用于媒介回放的video和audio元素
3. 本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除
4. 语意化更好的内容元素，比如 article footer header nav section
5. 位置API：Geolocation
6. 表单控件，calendar date time email url search
7. 新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket
8. 拖放API：drag、drop

移除的元素：

1. 纯表现的元素：basefont big center font s strike tt u
2. 性能较差元素：frame frameset noframes

区分：

1. DOCTYPE声明的方式是区分重要因素
2. 根据新增加的结构、功能来区分

## 5.**页面导入样式时，使用link和@import有什么区别？**

答：相同的地方，都是外部引用CSS方式，区别：

1. link是xhtml标签，除了加载css外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS
2. link引用CSS时候，页面载入时同时加载；@import需要在页面完全加载以后加载，而且@import被引用的CSS会等到引用它的CSS文件被加载完才加载
3. link是xhtml标签，无兼容问题；@import是在css2.1提出来的，低版本的浏览器不支持
4. link支持使用javascript控制去改变样式，而@import不支持
5. link方式的样式的权重高于@import的权重
6. import在html使用时候需要`<style type="text/css">`标签

## 6.null，undefined的区别？

- Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
- Null类型也只有一个值，即null。
- null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其他语言一样都代表“空值”，不过undefined却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。
- javascript权威指南：null 和 undefined 都表示 “值的空缺”，你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。
- javascript高级程序设计：在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。null值则是表示空对象指针。

## 7.添加 删除 替换 插入到某个接点的方法？

1）创建新节点
createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点

2）添加、移除、替换、插入
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插入

3）查找
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯一性

## 8.函数声明与函数表达式的区别？

在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。

## 9.new操作符具体干了什么呢?

1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。

## 10.请说出至少三种减低页面加载时间的方法？

1. 压缩css、js文件
2. 合并js、css文件，减少http请求
3. 外部js、css文件放在最底下
4. 减少dom操作，尽可能用变量替代不必要的dom操作

## 11.讲几个常见的js内置对象？

Object 是 JavaScript 中所有对象的父对象

数据封装类对象：Object、Array、Boolean、Number 和 String

其他对象：Function、Arguments、Math、Date、RegExp、Error

## 12.什么是事件冒泡？如何阻止事件冒泡？

冒泡机制中,水泡从下往上升,经过不同层次的区域,最终到达最外层，在js中,气泡就相当于`事件`，而水则相当于`整个dom树`；事件从dom 树的底层 层层往上传递，直至传递到dom的根节点。

阻止事件冒泡:event.stopPopagation()

## 13.什么是事件委托?

利用事件冒泡的原理，原本绑定在子元素身上的事件，现在绑定在父元素身上，由父元素监听事件的行为。

## 14.说一下你对this的理解？

 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同

1. 普通函数this在非严格模式下指向window，严格模式下指向undefined
2. 构造函数this指向实例对象，原型对象里面的方法也指向实例对象
3. 对象方法中的this指向该方法所属的对象
4. 事件绑定方法中的this指向绑定该事件的对象
5. 定时器函数的this指向window
6. 立即执行函数中的this指向window

## 15.什么是作用域和作用域链，请解释一下？

**作用域（scope）**

通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用性的范围即作用域，作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。

**作用域链（scope chain）**

一般情况下，变量取值到创建这个变量的函数的作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

## 16.Javascript的事件流模型都有什么?

“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡。

　　JS事件流最早要从IE和网景公司的浏览器大战说起，IE提出的是冒泡流，而网景提出的是捕获流，后来在W3C组织的统一之下，JS支持了冒泡流和捕获流，但是目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)，所以为了能够兼容更多的浏览器，建议大家使用冒泡流。

## 17.简述window对象除 document以外的一些常用子对象，并描述其作用？

window对象有很多子对象，除了 document以外，还有如下常用子对象：

- screen对象：此对象包含有关客户端显示屏幕的信息，常用于获取屏幕的分
  辨率和色彩；

- history对象：此对象包含用户（在浏览器窗口中）访问过的 URL；

- location对象：此对象包含有关当前 URL的信息，常用于获取和改变当前浏览的网址；

- navigator对象：此对象包含有关浏览器的信息，常用于获取客户端浏览器和操作系统信息；

- event对象：任何事件触发后将会产生一个 event对象，该对象记录事件发
  生时的鼠标位置、键盘按键状态和触发对象等信息。

## 18.BOM 和 DOM 的关系

  BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。

  DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。

  JS是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。

  可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。

## 19.flex属性举例说明

**父元素属性**
1.display:flex;（定义了一个flex容器）

2.flex-direction（决定主轴的方向）
   row（默认值，水平从左到右）colunm（垂直从上到下）row-reverse（水平从右到左）column-reverse（垂直从下到上）

3.flex-wrap（定义如何换行）
   nowrap（默认值，不换行）wrap（换行）wrap-reverse（换行，且颠倒行顺序，第一行在下方）
4.flex-flow（属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap）

5.justify-content（设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式）
   flex-start（ 默认值、弹性盒子元素将向行起始位置对齐）
   flex-end（弹性盒子元素将向行结束位置对齐）
   center（弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐）
   space-between（弹性盒子元素会平均地分布在行里）
   space-around（弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半）

6.align-items（设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式）
   flex-start（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界）
   flex-end（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界）
   center（ 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度））
   baseline（如弹性盒子元素的行内轴与侧轴为同一条，则该值与flex-start等效。其它情况下，该值将参与基线对齐。）
   stretch（如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制）

7.align-content（设置或检索弹性盒堆叠伸缩行的对齐方式）
   flex-start（各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行）
   flex-end（各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行）
   center（各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一      行之间的距离相等）
   space-between（各行在弹性盒容器中平均分布。第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则      按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等）
   space-around（ 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后      一行后面的空间是其他空间的一半）
   stretch（各行将会伸展以占用剩余的空间。剩余空间被所有行平分，以扩大它们的侧轴尺寸）
   **子元素上属性**
   1.order（默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数）

   2.flex-grow（设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间）

   3.flex-shrink（设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间）

   4.flex-basis (设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间)

   5.flex   (flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选)

```js
   //flex属性意义
   flex:none;   // flex : 0,0,auto;
   flex:auto;  // flex:1,1,auto;
   flex:1;    //  flex:1,1,0%;
```

6.align-self  (设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置)

## 20.请说出你熟悉的数组的操作方法并说出如何使用?
```js
//改变原数组方法:
var arr = []
arr.push()
arr.pop()
arr.unshift()
arr.shift()
arr.splice()
arr.reverse()
arr.sort()
//不改变原数组方法:
var arr = []
arr.includes();
arr.indexOf();
arr.lastIndexOf();
arr.slice();
arr.join();
arr.toString();
arr.concat();
```

## 21.localstorage、sessionstorage和cookie的区别

Storage 存储
Window.sessionStorage
window.localStorage
(向本地保存数据,有可能在浏览器内存里面，有可能在硬盘上面.)

特性
1、设置、读取方便
2、容量较大，sessionStorage约5M、localStorage约5M
3、只能存储字符串，可以将对象JSON.stringify() 编码后存储

window.sessionStorage
1、生命周期为关闭浏览器窗口
2、在同一个窗口下数据可以共享

window.localStorage
1、永久生效，除非手动删除
2、可以多窗口共享

方法详解
setItem(key, value) 设置存储内容
getItem(key) 读取存储内容
removeItem(key) 删除键值为key的存储内容
clear() 清空所有存储内容
key(n) 以索引值来获取存储内容

总结
三者共同点是都可以在本地进行数据存储，而且都是同源的
cookie 储存的信息非常小 只有4k 生存周期可以设置 默认是浏览器关闭
存储的数据每次都包含在http请求中往返于客户端与服务端之间

## 22.什么是跨域？ 如何解决跨域？


1、同源策略
- 是浏览器的安全策略
- 协议名、域名、端口号必须完全一致
2、跨域
- 违背同源策略就会产生跨域
3、解决跨域
- cors(后端配置)、 服务器代理（后端设置）、jsonp（前后端配合）、vue代理配置
- 然后介绍自己在项目中是如何去做的

## 23.如何编写高性能的JavaScript

- 将js脚本放在页面底部，加快渲染页面;

- 将js脚本成组打包，减少请求;

- 使用非阻塞方式下载js脚本;

- 尽量使用局部变量来保存全局变量;

- 尽量减少使用闭包;

- 使用window对象属性方法时省略window;

- 尽量减少对象成员嵌套;

- 缓存DOM节点的访问;

- 通过避免使用eval和function()构造器;

- 给setTimeout()和setInterval()传递函数而不是字符作为参数;

- 尽量使用直接量创建对象和数组;

- 最小化重绘(repaint)和回流(reflow)

## 24.标准盒模型 和ie盒模型区别(复习CSS知识等)

  标准盒模型是w3c 标准的盒模型，其包含：
  盒子占用宽度：margin + border+ padding + width
  实际宽度： border+ padding + width
  IE盒模型，在IE中content的宽度包括padding和border这两个属性，所以
  盒子占用宽度：margin + width
  实际宽度：width = padding + border + **内容宽度**

## 25.浏览器是如何渲染页面的？
```html
渲染的流程如下:
1.解析HTML文件，创建DOM树。
自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。
2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式。
3.将CSS与DOM合并，构建渲染树（Render Tree）。
4.布局和绘制，重绘（repaint）和重排（reflow）。
```
## 26.解释jsonp的原理，以及为什么不是真正的ajax
1.jsonp的原理:利用script标签可以获取不同源资源的特点，来达到跨域访问某个资源的目的。

2.为什么不是真正的 ajax?

- ajax的核心是 ： 通过XmlHttpRequest获取非本页内容，

- jsonp的核心 ： 动态添加<script>标签来调用服务器提供的js脚本。

3.ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；

4.jsonp是一种方式或者说非强制性的协议。
　ajax也不一定非要用json格式来传递数据。
5.jsonp只支持get请求，ajax支持get和post请求。

## 27.什么是ajax? ajax的步骤？
```js
ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。
如何使用ajax?
第一步，创建xmlhttprequest对象，var xmlhttp =new XMLHttpRequest（);
XMLHttpRequest对象用来和服务器交换数据。
if (window.XMLHttpRequest) {
//现代主流浏览器
xhttp = new XMLHttpRequest();
} else {
// 针对浏览器，比如IE5或IE6
xhttp = new ActiveXObject("Microsoft.XMLHTTP");
}
第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。
第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。
第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数。
```

## 27.说一下网络四层模型

    　　1、主机到网络层　　
    　　实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。　　
    　　2、网络互连层　　
    　　网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。　　
    　　网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。　　
    　　网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。　　
    　　3、传输层　　
    　　在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　
    　　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　　
    　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。　　
    　　4、应用层　　
    　　TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　
    　　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本传输协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。 
## 28.http和https的区别，在具体使用的时候有什么不一样
1.HTTP和HTTPS的基本概念
  HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
    
  HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
    
  HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

 2.HTTPS和HTTP的区别主要如下：

  1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    
  2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    
  3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    
  4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 29.在浏览器地址栏键入URL，按下回车之后会经历的流程

    1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
    
    2、解析出 IP 地址后，根据该 IP 地址和默认端口
    80，和服务器建立TCP连接;
    
    3、浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP
    请求，该请求消息作为 TCP三次握手的第三个报文的数据发送给服务器;
    
    4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器
    
    5、释放TCP连接;
    
    6、浏览器加载该 html 文本并显示内容; 　

```js
1、首先，在浏览器地址栏中输入url。
2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。
4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）
5、握手成功后，浏览器向服务器发送http请求，请求数据包。
6、服务器处理收到的请求，将数据返回至浏览器。
7、浏览器收到HTTP响应。
8、读取页面内容，浏览器渲染，解析html源码。
9、生成Dom树、解析css样式、js交互。
10、客户端和服务器交互。
11、ajax查询。
```
## 30.HTTP状态码
```js
HTTP 响应中包含一个状态码，用来表示服务器对客户端响应的结果。
状态码一般由3位构成：
 
1xx : 表示请求已经接受了，继续处理。
2xx : 表示请求已经处理掉了。
3xx : 重定向。
4xx : 一般表示客户端有错误，请求无法实现。
5xx : 一般为服务器端的错误。
 
比如常见的状态码：
 
200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。
```

## 31.什么是原型?什么是原型链?

#### 原型

> ①所有`函数`都有一个`prototype(原型)`属性，属性值是一个普通的对象
> ②所有`引用类型`都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象
> ③所有`引用类型的__proto__`属性`指向`它`构造函数的prototype`

#### 原型链

> 每一个实例对象都有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。


## 32.数组函数some、every、filter、map、forEach有什么区别？

#### some

1、不创建新数组
2、不改变原数组
3、输出的是判断为true则马上跳出循环并return成true
4、回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
5、使用return操作输出，会循环数组每一项，并在回调函数中操作

#### every(与some相反)

1、不创建新数组
2、不改变原数组
3、输出的是判断为false则马上跳出循环并return成false
4、回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
5、使用return操作输出，会循环数组每一项，并在回调函数中操作

#### filter

1、创建新数组
2、不改变原数组
3、**输出的是判断为true的数组元素形成的新数组**
4、回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
5、使用return操作输出，会循环数组每一项，并在回调函数中操作

#### map

1、创建新数组
2、不改变原数组
3、输出的是return什么就输出什么新数组
4、回调函数参数，item(数组元素)、index(序列)、arr(数组本身)
5、使用return操作输出，会循环数组每一项，并在回调函数中操作

#### forEach

遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次数，且无法break中途跳出循环
不支持return操作输出，return只用于控制循环是否跳出当前循环
## 33.说一下你对this的理解？

 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同

1. 普通函数this在非严格模式下指向window，严格模式下指向undefined
2. 构造函数this指向实例对象，原型对象里面的方法也指向实例对象
3. 对象方法中的this指向该方法所属的对象
4. 事件绑定方法中的this指向绑定该事件的对象
5. 定时器函数的this指向window
6. 立即执行函数中的this指向window

## 34.call、apply、bind三者的异同？

- 共同点 : 都可以改变this指向
- 不同点:
  - call 和 apply  会调用函数, 并且改变函数内部this指向.
  - call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递
  - bind  不会立即调用函数, 可以改变函数内部this指向.

- 应用场景

  1. call 经常做继承. 
  2. apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值
  3. bind  不会立即调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 

## 35.JavaScript 中有哪些不同的函数调用模式？ 详细解释。

提示：有四种模式，函数调用，方法调用，`.call()` 和 `.apply()`。

## 36.说一下你对作用域的理解？

变量根据作用域的不同分为两种：全局变量和局部变量。

1. 函数内部可以使用全局变量。
2. 函数外部不可以使用局部变量。
3. 当函数执行完毕，本作用域内的局部变量会销毁。

## 37.**什么是闭包？**

闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。

**使用闭包的注意点**
（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

## 38.什么是内存泄漏？哪些操作会造成内存泄漏

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）.

1. 意外的全局变量引起的内存泄露
2. 闭包引起的内存泄露 
3. 没有清理的DOM元素引用 
4. 被遗忘的定时器或者回调  
5. 子元素存在引起的内存泄露  

## 39.JS的垃圾回收机制是什么?你得理解?

最常使用的方法叫做["引用计数"](https://en.wikipedia.org/wiki/Reference_counting)（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放。JS的垃圾回收机制是为了以防内存泄漏，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。

## 40.JS面对对象有那些特性,怎样实现

对象三大特性:封装,继承,多态

- 封装:将面向过程每一步进行推进:对同种对象的属性和方法进行抽象，成为一个类(js中没有类的概念，实际上也是一个对象)，然后通过类的方法和属性来访问类

- 继承:在封装的基础上，将同类事物继续抽象，继承时，子类拥有父类的属性和方法，同时拥有自己特有的属性和方法

  js的继承实现方法：
  1.属性拷贝（浅拷贝）
  2.属性拷贝（深拷贝）
  3.原型式继承
  4.原型链继承
  5.借用构造函数

- 多态:不同对象对同一事物做出不同的回应，通常出现在继承后对方法的重写

## 41.浅拷贝和深拷贝的区别？

  **深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。**

  1. 浅拷贝(shallow copy)：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存;

  2. 深拷贝(deep copy)：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变;

## 42.用过严格模式吗？为什么使用严格模式？

     javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？
     use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行。
     使用它区别是：
     使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
     默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
     全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数;
     消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
     提高编译器效率，增加运行速度；
     为未来新版本的Javascript标准化做铺垫。
## 43.栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

## 44.栈和堆的区别？

栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。

   堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

   栈（数据结构）：一种先进后出的数据结构

## 45.总结String 对象操作方法

| 方法           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| charAt()       | 返回在指定位置的字符。                                       |
| charCodeAt()   | 返回在指定的位置的字符的 Unicode 编码。                      |
| concat()       | 连接两个或更多字符串，并返回新的字符串。                     |
| fromCharCode() | 将 Unicode 编码转为字符。                                    |
| indexOf()      | 返回某个指定的字符串值在字符串中首次出现的位置。             |
| includes()     | 查找字符串中是否包含指定的子字符串。                         |
| lastIndexOf()  | 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 |
| search()       | 查找与正则表达式相匹配的值。                                 |
| slice()        | 提取字符串的片断，并在新的字符串中返回被提取的部分。不包含结束的索引 |
| split()        | 把字符串分割为字符串数组。                                   |
| substr()       | 从起始索引号提取字符串中指定数目的字符。                     |
| substring()    | 提取字符串中两个指定的索引号之间的字符。                     |
| toLowerCase()  | 把字符串转换为小写。                                         |
| toUpperCase()  | 把字符串转换为大写。                                         |
| trim()         | 去除字符串两边的空白                                         |
| toString()     | 返回一个字符串。                                             |